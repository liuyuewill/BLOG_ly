### 编程原则
- 单一职责、
- 里氏替换、
- 依赖倒置、
- 接口隔离、
- 合成复用、
- 最少知识

### 单一职责
一个对象(方法)只做一件事情
- 代理模式
让代理去进行预加载，让本体去修改src
- 迭代器模式

        反例：
        var appendDiv = function( data ){
            for ( var i = 0, l = data.length; i < l; i++ ){
            var div = document.createElement( 'div' );
            div.innerHTML = data[ i ];
            document.body.appendChild( div );
        } };

        appendDiv( [ 1, 2, 3, 4, 5, 6 ] );

        原因：
        appendDiv只负责渲染数据，但这里，它还承担了遍历聚合对象data的职责。如果以后data格式变为一个obj，那还得修改appendDiv

        优化：
        把遍历 data 的职责提出来，这正是迭代器模式的意义，迭代器模式提供了一种方法【来访问聚合对象】，而不用暴露这个对象的内部表示

        var each = function( obj, callback ) { // 写一个内部迭代器
            var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike( obj );

            if ( isArray ) { // 迭代类数组
                for ( ; i < length; i++ ) {
                    // isArraylike 函数未实现，可以翻阅 jQuery 源代码
                    callback.call( obj[ i ], i, obj[ i ] ); }
            } else {
                for ( i in obj ) { // 迭代object对象
                    value = callback.call( obj[ i ], i, obj[ i ] )
                }
            }
            return obj;
        };
        var appendDiv = function( data ){
            each( data, function( i, n ){
                var div = document.createElement( 'div' );
                div.innerHTML = n; document.body.appendChild( div );
            });
        };
        appendDiv( [ 1, 2, 3, 4, 5, 6 ] );
        appendDiv({a:1,b:2,c:3,d:4} );
- 单例模式

        反例：
        var createLoginLayer = (function(){
            var div;
            return function(){
                if ( !div ){
                    div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗';
                    div.style.display = 'none'; document.body.appendChild( div );
                }
                return div;
            }
        })();
        原因：管理单例的职责 和 创建登录浮窗 放在了同一个函数里，不应该
        优化：
        const createLoginLayer = function() {
            const div = document.createElement('div')
            div.innerHTML = 'HELLO WORLD'
            div.style.display = 'none'
            document.body.appendChild(div)
            return div
        }
        function getSingle (fn){
            let res = null  // 重点部分，是个闭包
            return function (){
                return res || res = fn.apply(this, arguments)
            }
        }

        var createSingleLoginLayer = getSingle( createLoginLayer );
        var loginLayer1 = createSingleLoginLayer();
        var loginLayer2 = createSingleLoginLayer();
        alert ( loginLayer1 === loginLayer2 ); // 输出: true



