### css

- BFC:  https://juejin.im/post/59b73d5bf265da064618731d

  练习题：https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/

  如何实现，左边盒子固定宽高，右边自适应

  - 法一：双 inline-block 方法，重点是：右侧边宽 width: calc(100% -140px左边宽)
  - 法二：双 float, 原理还同法一
  - 法三：BFC

- SCSS (SASS 3.0 版本分出了另一种写法 SCSS，其实语法完全一样，官网就看SASS)

  - 变量

  - 嵌套

  - 混入

    ```CSS
    1、普通混入
    @mixin no-bullets {
      list-style: none;
      li {
        list-style-image: none;
        list-style-type: none;
        margin-left: 0px;
      }
    }
    
    ul.plain {
      color: #444;
      @include no-bullets;
    }
    
    2、混入传参
    ```

  - 条件

  - 循环

  - 运算

### JS

- 作用域

  执行上下文在创建时会确认 变量对象、作用域 及 this的指向。

  作用域可以理解为该执行上下文中声明的 变量和声明 的作用范围。

  - 块作用域
  - 函数作用域

- this

  什么是this? JS的设计原理：在函数中，可以引用运行环境中的变量对象，于是，this就是用来获取当前运行环境的。因此要弄清this的指向，你弄明白当前的运行环境不就好了嘛

- 作用域链

  可以理解为一组对象列表，包含父级和自身的变量对象。于是就可以通过作用域链访问到父级的变量或函数。

- 闭包

  - 本质：一个函数而已

  - 特点：能保存外部函数的变量（因为：**内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放**）

  - 闭包的应用

    ```JS
    1、模仿块级作用域
    匿名立即执行函数内会形成一个闭包，外部无法访问它内部的变量对象
    function A(num) {
        //核心代码
       (funnction(){ // 这个匿名自执行函数，外部不能访问这内部的变量，但它能访问外部的变量，所以它就是一个闭包函数
          for(var i = 0; i<num; i++) {
            num++;
          }
        })()
        //核心代码结束
        console.log(i)//underfined，所以上面这个闭包有块作用域的功能，算得上是模仿块级作用域了
      }
      
     2、可以利用闭包可以保存外部变量的特征，存储比较重要或者计算耗费很大的值存在x中（单例模式、防抖、节流就利用了这点）
       function B(){
          var x = 100;
          return {
              function(){
                  return x
              }
          }
      }
      var m = B()//运行B函数，生成活动变量 x被m引用
    
    ```

  - 闭包产生的问题：
    - 因为父级里的变量对象是共享的，所以被修改时，会影响所有的子函数

      ```JS
      解决方法：
      1、变量通过参数传入
      2、使用 setTimeout 包裹，通过第三个参数传入
      ```

    - 闭包过多，内存泄漏，所以可手动解除对父返回的匿名函数的引用，以便释放内存。

- 浅复制、深复制

  ```js
  涉及知识：
  数据类型分为两种：
  1、基本数据类型：放在栈内存中。因为栈内存里的数据要求大小固定，可能按值访问。
  2、引用类型：放在堆内存中。因为引用类型大小不固定，只能放在堆里。我们可以把它的引用地址，写在栈内存里以供访问。
  
  
  复制：
  在复制基本数据类型时，我们直接使用 = 完成复制
  在引用类型的时候，我们 循环遍历对象，对每个属性或值使用 = 完成复制
  ```

  

  浅复制：只复制第一层属性

  深复制：**对属性中所有引用类型的值，遍历到是基本类型的值为止**

  ```JS
  function deepCopy(obj){ // obj 可能是数组，也可能是对象
    var result;
    let type = Object.prototype.toString.call(obj)
    if ( type === '[object Object]'){
      result = {}
      for(let key in obj) {
        result[key] = deepCopy(obj[key])
      }
    } else if (type === '[object Array]') {
      result = []
      for(let i=0; i<obj.length; i++){
        result[i] = deepCopy(obj[i])
      }
    } else {
      return obj
    }
    return result
  }
  ```

- 代码复用的方式
  - 函数封装
  - 原型继承
  - es6的class/extends
  - mixins
  - Apply/call借用

- 类型判断

  - 基本类型(`null`): 使用 `String(null)`
  - 基本类型(`string / number / boolean / undefined`) + `function`: 直接使用 `typeof`即可
  - 其余引用类型(`Array / Date / RegExp Error`): 调用Object.prototype.`toString`.call(obj)后根据`[object XXX]`进行判断

- require 和 import 的区别

  - require 是代码进行到这一步执行，import是在编译时执行
  - require 是同步导入，import 是异步引入
  - require 是值拷贝，import 指向内存地址

- 防抖 debounce： 优化为只在最后一次执行

  场景：用户输入，输入完成后做一次校验即可(表格中常用)

  ```JS
  function debounce(fn, interval, immediate){
    var timer = null
    var isImmediate = immediate
    return function () {
      let context = this
      let args = arguments
      
      if(!timer && isImmediate){
        fn.apply(context, args)
        isImmediate = false
      }
      if (timer){
        clearTimeout(timer)
      }
      timer = setTimout(()=>{ // 因为这里写的是箭头函数，所以其实可以直接写 this,arguments
        fn.apply(context, args)
      },interval)
    }
  }
  ```

  

- 节流 throttle：将高频操作优化成低频操作，固定时间执行一次

  场景：滚动条事件、resize事件

  ```JS
  function throttle(fn, interval, immediate){
    var timer = null
    var isImmediate = immediate
    return function () {
      if(!timer && isImmediate){
        fn.apply(this, arguments)
        isImmediate = false
      }
      if(!timer){
        timer = setTimerout(() => {
          fn.apply(this, arguments)
          timer = null
        }, interval)
      }
    }
  }
  ```

### ES6/ES7

- const/let

  - 相同：1、块级作用域 2、变量不能提升 3、不能重复声明 4、暂时性死区

    ```JS
    暂时性死区：
      会使区块形成封闭的作用域，在变量被声明之前使用变量，就会报错 x is not defined
    导致：
      typeof 不再是安全操作，如：
    	typeof a // ReferenceError: a is not defined
    	let a
    ```

  - 不同: 声明常量，无法修改