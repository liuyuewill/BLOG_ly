- 作用域链其实是`变量对象/活动对象串起来的

- 闭包
  
  - 本质：一个函数而已
  
  - 特点：能保存外部函数的变量（因为：**内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放**）
  
  - 闭包的应用
  
    ```JS
    1、模仿块级作用域
    匿名立即执行函数内会形成一个闭包，外部无法访问它内部的变量对象
    function A(num) {
        //核心代码
       (funnction(){ // 这个匿名自执行函数，外部不能访问这内部的变量，但它能访问外部的变量，所以它就是一个闭包函数
          for(var i = 0; i<num; i++) {
            num++;
          }
        })()
        //核心代码结束
        console.log(i)//undefined，所以上面这个闭包有块作用域的功能，算得上是模仿块级作用域了
      }
      
     2、可以利用闭包可以保存外部变量的特征，存储比较重要或者计算耗费很大的值存在x中（单例模式、防抖、节流就利用了这点）
       function B(){
          var x = 100;
          return {
              function(){
                  return x
              }
          }
      }
      var m = B()//运行B函数，生成活动变量 x被m引用
    
    ```
  
  - 闭包产生的问题：
  
    - 因为父级里的变量对象是共享的，所以被修改时，会影响所有的子函数
  
      ```JS
      解决方法：
      1、变量通过参数传入
      2、使用 setTimeout 包裹，通过第三个参数传入
      ```
  
    - 闭包过多，内存泄漏，所以可手动解除对父返回的匿名函数的引用，以便释放内存。

- this

  - 注意点：

    - 在执行上下文被创建时确定的（也即，**是在函数被调用的时候确定的**）
    - this指向一旦确定，就不会再变

  - 四种情况

    - 全局对象（严格模式下， 则指向undefined

    - 调用者

    - 构造函数的实例

      通过new操作符调用构造函数，依次经历4个阶段

      - 创建一个新的对象
      - 将构造函数的this指向这个新对象
      - 指向构造函数的代码，为这个对象添加属性，方法等；
      - 返回新对象

    - call/apply/bind

  