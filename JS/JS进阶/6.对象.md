### 工厂模式

```js
var createPerson = function(name, age) {

    // 声明一个中间对象，该对象就是工厂模式的模子
    var o = new Object();

    // 依次添加我们需要的属性与方法
    o.name = name;
    o.age = age;
    o.getName = function() {
        return this.name;
    }

    return o;
}

// 创建两个实例
var perTom = createPerson('TOM', 20);
var PerJake = createPerson('Jake', 22);




不足1：无法识别对象的类型，如：（用构造对象来解决）
var obj = {};
var foo = function() {}
console.log(obj instanceof Object);  // true
console.log(foo instanceof Function); // true

不足2：每个实例都有自己的getName方法，其实功能一致，没有必要（用原型来解决）
```

### 构造函数

- new都干了什么

- ```js
  function Person (name) {
    this.name = name
    this.getName = function() {
      return this.name
    }
  }
  
  function New(fun){
    let res = {} // 要返回的实例对象
    let ret = fun.apply(res) // 改变构建函数fun里this的指向
    if (func.prototype !== null) {
      ret._proto_ = func.prototype // 把构建函数原型上的属性、方法，挂在实例对象上
    }
    if (typeof ret === 'object' || typeof ret === 'function'){ // 如果构建函数有自己确定的返回的内容，就返回它要返回的
        return ret
    }
    return res // 否则，返回一个新对象
  }
  
  
  
  var p1 = New(Person, 'tom');
  console.log(p1.getName());
  ```

- 小结

  - 声明一个中间对象；
  - 将该中间对象的原型指向构造函数的原型；
  - 将构造函数的this，指向该中间对象；
  - 返回该中间对象，即返回实例对象。

### 原型

- 构造函数的prototype与所有实例对象的`__proto__`都指向原型对象。而原型对象的constructor指向构造函数

- in：一个对象是否拥有某一个属性/方法，无论是该属性/方法存在与实例对象还是原型对象

- ``` JS
  in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开
  isMobile = 'ontouchstart' in document;
  ```

- 注意：

  ```JS
  function Person() {}
  
  Person.prototype = {
      constructor: Person, // 注意
      getName: function() {},
      getAge: function() {},
      sayHello: function() {}
  }
  ```

### 继承

