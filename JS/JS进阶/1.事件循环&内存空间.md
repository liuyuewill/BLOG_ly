### 事件循环
- 浏览器是多进程的

- JS是单线程的，此单线程中拥有唯一的事件循环，事件循环中的队列可以有多个

- JavaScript代码的执行过程中，除了依靠`函数调用栈`来搞定函数的执行顺序外，还依靠`任务队列`(task queue)来搞定另外一些代码的执行

- 队列：先进先出
  - macro-task宏任务：script(整体代码), setTimeout队列, setInterval队列, setImmediate, requestAnimationFrame, I/O, UI rendering。
  - micro-task微任务：process.nextTick, Promise队列, Object.observe(已废弃), MutationObserver(html5新特性)
  
- 浏览器循环机制：
  - 从macro-task开始，找到其中`一个任务队列`执行完毕，然后再执行`所有的micro-task`，这样一直循环下去(一对多)
  - 当我们在执行setTimeout任务中遇到setTimeout时，它仍然会将对应的任务分发到setTimeout队列中去，但是该任务就得等到下一轮事件循环执行了
  
- 什么是EventLoop

  浏览器是单线程的，从上往下依次执行，如果遇到像Ajax这种异步请求，浏览器会把异步请求放给处理异步的模块来处理，当异步请求的结果回来之后，会将处理异步结果的函数放进队列里，当主线程执行结束以后，就会在队列里找微任务，处理完所有的微任务后，就再去宏任务队列里执行一个任务队列（如：setTimeout队列，这个队列里可能有好几个setTtimeout回调函数），再处理完所有的微任务。这样的循环执行，叫作eventloop

  ```JS

  这波能反杀的解释：

  来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。
  事件循环的顺序，决定了JavaScript代码的执行顺序。
  它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。
  当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。
  其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。

---
### 内存空间
- 栈空间存储原理：先进后出
- 堆：存储的key-value是可以无序的
- 队列：先进先出
- 变量对象与基础数据类型
  - JavaScript的执行上下文生成之后，会创建一个`变量对象`
  - JavaScript的`基础数据类型`都会保存在变量对象中
  - 基础数据类型都是按值访问
  - 引用类型的值都是按引用访问的
    - `引用数据类型`的值是保存在`堆内存`中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间,在操作对象时，实际上是在操作对象的引用而不是实际的对象
- 内存空间管理
  - 自动垃圾收集机制: 标记清除的算法